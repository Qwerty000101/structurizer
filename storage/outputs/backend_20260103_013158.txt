–ê–Ω–∞–ª–∏–∑ –ø—Ä–æ–µ–∫—Ç–∞: C:\Users\HAIER\Desktop\LLM\test\backend

–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞:
‚îî‚îÄ‚îÄ backend
    ‚îú‚îÄ‚îÄ credentials
    ‚îÇ   ‚îî‚îÄ‚îÄ gigachatApi.credentials.ts
    ‚îú‚îÄ‚îÄ engine
    ‚îÇ   ‚îî‚îÄ‚îÄ executionFunctions
    ‚îú‚îÄ‚îÄ helpers
    ‚îÇ   ‚îú‚îÄ‚îÄ expressionResolver.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ index.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ templateResolver.ts
    ‚îú‚îÄ‚îÄ nodes
    ‚îÇ   ‚îú‚îÄ‚îÄ EditFields.node.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ GigaChat.node.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ If.node.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ Input.node.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ ManualTrigger.node.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ Output.node.ts
    ‚îú‚îÄ‚îÄ routes
    ‚îÇ   ‚îú‚îÄ‚îÄ credentials.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ credentialTypes.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ workflow.ts
    ‚îú‚îÄ‚îÄ services
    ‚îÇ   ‚îú‚îÄ‚îÄ credentialsStore.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ credentialTypeRegistry.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ encryption.ts
    ‚îú‚îÄ‚îÄ types
    ‚îÇ   ‚îú‚îÄ‚îÄ credentials.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ helpers.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ nodes.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ workflow.ts
    ‚îú‚îÄ‚îÄ utils
    ‚îÇ   ‚îî‚îÄ‚îÄ errorHandler.ts
    ‚îú‚îÄ‚îÄ workflows
    ‚îÇ   ‚îú‚îÄ‚îÄ gigachat_test-1765127473899.json
    ‚îÇ   ‚îú‚îÄ‚îÄ manualtrigger_test-1764975724050.json
    ‚îÇ   ‚îú‚îÄ‚îÄ –º–æ—è-—Å—Ö–µ–º–∞-1765113295136.json
    ‚îÇ   ‚îî‚îÄ‚îÄ –º–æ—è-—Å—Ö–µ–º–∞1244123-1765128404172.json
    ‚îú‚îÄ‚îÄ .env
    ‚îú‚îÄ‚îÄ credentialsRegistry.ts
    ‚îú‚îÄ‚îÄ executionEngine.ts
    ‚îú‚îÄ‚îÄ nodeRegistry.ts
    ‚îú‚îÄ‚îÄ package-lock.json
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ server.ts
    ‚îî‚îÄ‚îÄ tsconfig.json

–¢–µ–∫—Å—Ç –∏–∑ —Ñ–∞–π–ª–æ–≤ –ø—Ä–æ–µ–∫—Ç–∞:

–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\credentialsRegistry.ts:
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { ICredentialType } from "./types/credentials";

/**
 * –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤ credentials
 */
const credentialTypes = new Map<string, ICredentialType>();

// –ü—É—Ç—å –∫ –ø–∞–ø–∫–µ credentials
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const credentialsDir = path.join(__dirname, "credentials");

/**
 * –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤—Å–µ—Ö *.credentials.ts –∫–∞–∫ –≤ n8n
 */
function loadCredentialTypes() {
  if (!fs.existsSync(credentialsDir)) return;

  const files = fs.readdirSync(credentialsDir);

  for (const file of files) {
    if (!file.endsWith(".credentials.ts") && !file.endsWith(".credentials.js")) continue;

    const fullPath = path.join(credentialsDir, file);

    try {
      const module = require(fullPath);
      const credType: ICredentialType = module.default;

      credentialTypes.set(credType.name, credType);

      console.log(`üîê –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω credential type: ${credType.name}`);
    } catch (err) {
      console.error(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ credential type ${file}:`, err);
    }
  }
}

// –ó–∞–≥—Ä—É–∂–∞–µ–º –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
loadCredentialTypes();

/**
 * –ü–æ–ª—É—á–∏—Ç—å —Ç–∏–ø –ø–æ –∏–º–µ–Ω–∏
 */
export function getCredentialType(name: string): ICredentialType | undefined {
  return credentialTypes.get(name);
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ —Ç–∏–ø—ã (–¥–ª—è UI)
 */
export function getAllCredentialTypes(): ICredentialType[] {
  return [...credentialTypes.values()];
}


–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\executionEngine.ts:
// backend/engine/executionEngine.ts
import {
    IWorkflowNodeInstance,
    IWorkflowConnection,
    INodeExecutionData,
    IExecutionMap
} from "./types/workflow";
import { resolveTemplate } from "./helpers/templateResolver";
import { INodeType } from "./types/nodes";
import { getNodeType } from "./nodeRegistry";
import { createHelpers } from "./helpers";
import { IExecuteFunctions } from "./types/nodes";
import { evalExpression } from "./helpers/expressionResolver";

interface IExecutionResults {
    [nodeId: string]: {
        [outputPort: string]: INodeExecutionData[];
    };
}

/**
 * –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≥–æ—Ç–æ–≤—ã –ª–∏ –≤—Å–µ –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –Ω–æ–¥—ã
 */
function areInputsReady(
    node: IWorkflowNodeInstance,
    connections: IWorkflowConnection[],
    results: IExecutionResults
): boolean {
    const incoming = connections.filter(c => c.target === node.id);
    if (incoming.length === 0) return true;

    for (const conn of incoming) {
        const r = results[conn.source];
        
        // –ï—Å–ª–∏ sourceHandle –Ω–µ –∑–∞–¥–∞–Ω, —Å—á–∏—Ç–∞–µ–º —ç—Ç–æ –¥–µ—Ñ–æ–ª—Ç–Ω—ã–º 'output'
        const port = conn.sourceHandle || "output"; 
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –¥–∞–Ω–Ω—ã–µ –∏–º–µ–Ω–Ω–æ –Ω–∞ —ç—Ç–æ–º –ø–æ—Ä—Ç—É
        if (!r || !r[port]) {
            return false;
        }
    }
    return true;
}

/**
 * –°–æ–±–∏—Ä–∞–µ–º –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –Ω–æ–¥—ã
 */
function collectInputs(
    node: IWorkflowNodeInstance,
    connections: IWorkflowConnection[],
    results: IExecutionResults
): Record<string, INodeExecutionData[]> | INodeExecutionData[] {
    const incoming = connections.filter(c => c.target === node.id);
    if (incoming.length === 0) {
        return [];
    }

    const inputs: Record<string, INodeExecutionData[]> = {};
    for (const conn of incoming) {
        const sourceResult = results[conn.source];
        
        const sourcePort = conn.sourceHandle || "output";
        const targetPort = conn.targetHandle || "input";

        if (sourceResult && sourceResult[sourcePort]) {
            if (!inputs[targetPort]) inputs[targetPort] = [];
            inputs[targetPort].push(...sourceResult[sourcePort]);
        }
    }

    const ports = Object.keys(inputs);
    
    // –ï—Å–ª–∏ –º—ã —Å–æ–±—Ä–∞–ª–∏ –¥–∞–Ω–Ω—ã–µ —Ç–æ–ª—å–∫–æ –¥–ª—è –æ–¥–Ω–æ–≥–æ –ø–æ—Ä—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä 'input'), 
    // –∏ –Ω–æ–¥–∞ –æ–∂–∏–¥–∞–µ—Ç –º–∞—Å—Å–∏–≤ (–∫–∞–∫ GigaChat), —É–ø—Ä–æ—â–∞–µ–º –≤–æ–∑–≤—Ä–∞—Ç.
    if (ports.length === 1 && ports[0] === 'input') {
        return inputs['input'];
    }
    
    // –ò–Ω–∞—á–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –æ–±—ä–µ–∫—Ç { input: [...], input2: [...] }
    return inputs;
}

/**
 * –û—Å–Ω–æ–≤–Ω–æ–π –¥–≤–∏–∂–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è workflow
 */
export async function executeWorkflow(
    nodes: IWorkflowNodeInstance[],
    connections: IWorkflowConnection[],
    options?: {
        mode?: "production" | "test-trigger" | "test-node";
        startNodeId?: string;
        testInputItems?: INodeExecutionData[];
    }
) {
    const nodeExecutionInputs: Record<string, any> = {};
    const nodeExecutionTimes: Record<string, { startTime: number; endTime: number }> = {};
    const startTime = Date.now();
    
    console.log("üß† [Engine] –ó–∞–ø—É—Å–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å—Ö–µ–º—ã (TS, n8n-like)");
    console.log("üìã Nodes:", nodes.map(n => `${n.id} (${n.type})`));
    console.log("üîó Connections:", connections.map(c => `${c.source} -> ${c.target}`));

    const results: IExecutionResults = {};
    const visited = new Set<string>();
    const queue: IWorkflowNodeInstance[] = [];

    // ======= –ù–û–í–´–ô –í–´–ë–û–† –°–¢–ê–†–¢–û–í–û–ô –ù–û–î–´ (n8n-like) =======
    const mode = options?.mode ?? "production";
    const startNodeId = options?.startNodeId;

    if (mode === "test-node" && startNodeId) {
        const startNode = nodes.find(n => n.id === startNodeId);
        if (!startNode) {
            throw new Error(`Start node not found: ${startNodeId}`);
        }

        console.log(`üöÄ [TEST-NODE] Starting from: ${startNode.id}`);

        // –ï—Å–ª–∏ –µ—Å—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–µ –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ ‚Äî —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ —ç—Ç–∞ –Ω–æ–¥–∞ –∏—Ö —É–∂–µ "–ø–æ–ª—É—á–∏–ª–∞"
        if (options?.testInputItems) {
            results[startNode.id] = {
                input: options.testInputItems
            };
        }

        queue.push(startNode);
    } else if (mode === "production" || mode === "test-trigger") {
        const triggerNodes = nodes.filter(node => {
            const nodeType = getNodeType(node.type);
            return nodeType?.description?.trigger === true;
        });

        if (!triggerNodes.length) {
            console.warn("‚ö†Ô∏è No trigger nodes found in workflow");
        }

        for (const node of triggerNodes) {
            console.log(`üöÄ [TRIGGER] Starting node: ${node.id} (${node.type})`);
            queue.push(node);
        }
    }

    console.log(`üìä Initial queue:`, queue.map(n => n.id));

    let loop = 0;
    const MAX = nodes.length * 3;

    while (queue.length > 0 && loop++ < MAX) {
        console.log(`\n--- Loop ${loop} ---`);
        console.log(`üìã Queue:`, queue.map(n => n.id));
        
        const node = queue.shift()!;
        console.log(`üéØ Processing node: ${node.id} (${node.type})`);

        if (visited.has(node.id)) {
            console.log(`‚è© Already visited, skipping`);
            continue;
        }

        if (!areInputsReady(node, connections, results)) {
            console.log(`‚è≥ Inputs not ready, re-queuing ${node.id}`);
            queue.push(node);
            continue;
        }

        visited.add(node.id);
        console.log(`‚úÖ Marked as visited: ${node.id}`);

        const nodeType: INodeType | undefined = getNodeType(node.type);
        if (!nodeType) {
            console.warn(`‚ö†Ô∏è –ù–æ–¥–∞ "${node.type}" –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞.`);
            continue;
        }

        const helpers = createHelpers(`Node:${node.type}`, {
            results,
            nodes
        });
        
        const inputData = collectInputs(node, connections, results);
        const inputsMap: Record<string, INodeExecutionData[]> = Array.isArray(inputData) 
            ? { "input": inputData } 
            : inputData;
        
        // ======= –ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï: –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –î–û –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è =======
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —ç—Ç–æ–π –Ω–æ–¥—ã (–∫–æ–ø–∏—Ä—É–µ–º –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è)
        nodeExecutionInputs[node.id] = JSON.parse(JSON.stringify(inputsMap));
        
        // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –≤—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
        const nodeStartTime = Date.now();
        nodeExecutionTimes[node.id] = { 
            startTime: nodeStartTime, 
            endTime: nodeStartTime 
        };

        const executeFunctions: IExecuteFunctions = {
            helpers: helpers,

            getNode: () => ({
                id: node.id,
                name: node.data?.name || node.id,
                type: node.type
            }),

            getInputData: (inputName: string = 'input') => {
                return inputsMap[inputName] || [];
            },

            getNodeParameter: (paramName: string, itemIndex: number, fallbackValue?: any) => {
                // 1. –ë–µ—Ä–µ–º "—Å—ã—Ä–æ–µ" –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫
                const rawValue = node.data?.[paramName];

                if (rawValue === undefined) {
                    return fallbackValue;
                }

                // 2. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç —ç–ª–µ–º–µ–Ω—Ç–∞ (–¥–ª—è $json)
                const currentItem = (inputsMap['input'] || [])[itemIndex];
                const context = {
                    json: currentItem?.json || {},
                    itemIndex,
                    inputItems: inputsMap['input'],
                    executionResults: results,
                    nodes: nodes,
                    env: process.env,
                    currentNodeId: node.id,
                    mode: options?.mode
                };
                
                // 1. –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ —Å—Ç—Ä–æ–∫–∞ (—á–∏—Å–ª–æ, –±—É–ª–µ–≤–æ) ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å
                if (typeof rawValue !== 'string') {
                    return rawValue;
                }

                // 2. –ï—Å–ª–∏ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å {{ ‚Äî —ç—Ç–æ "–ß–∏—Å—Ç–æ–µ –í—ã—Ä–∞–∂–µ–Ω–∏–µ"
                if (rawValue.trim().startsWith('{{')) {
                    return evalExpression(rawValue, context);
                }

                // 3. –ò–Ω–∞—á–µ —ç—Ç–æ "–°—Ç—Ä–æ–∫–∞ —Å –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∞–º–∏"
                return resolveTemplate(rawValue, currentItem?.json || {}, context);
            }
        };
        
        helpers.log(`–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –Ω–æ–¥—ã. ID=${node.id}, —Ç–∏–ø="${node.type}"`);
        console.log(`üì• Input data for ${node.id}:`, Array.isArray(inputData) 
            ? `array with ${inputData.length} items` 
            : `object with ports: ${Object.keys(inputData)}`
        );
        
        let execResult: any;
        try {
            // –í—ã–ø–æ–ª–Ω—è–µ–º –Ω–æ–¥—É
            execResult = await nodeType.execute.call(executeFunctions);
            console.log(`‚úÖ Node ${node.id} executed successfully`);
        } catch (err: any) {
            helpers.log("–û—à–∏–±–∫–∞ –Ω–æ–¥—ã:", err.message);
            results[node.id] = {
                output: [{ json: { error: err.message } }],
            };
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è –ø—Ä–∏ –æ—à–∏–±–∫–µ
            nodeExecutionTimes[node.id].endTime = Date.now();
            continue;
        }

        // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        const normalized: IExecutionResults[string] = {};

        if (Array.isArray(execResult)) {
            normalized["output"] = execResult;
        } else if (typeof execResult === "object") {
            for (const port of Object.keys(execResult)) {
                normalized[port] = execResult[port];
            }
        } else {
            normalized["output"] = [];
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –≤—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è
        nodeExecutionTimes[node.id].endTime = Date.now();
        
        results[node.id] = normalized;
        console.log(`üíæ Saved results for ${node.id}:`, Object.keys(normalized));

        // –î–æ–±–∞–≤–ª—è–µ–º —Å–ª–µ–¥—É—é—â–∏–µ –Ω–æ–¥—ã
        const outgoing = connections.filter(c => c.source === node.id);
        console.log(`üîó Outgoing connections from ${node.id}:`, outgoing.length);
        
        for (const conn of outgoing) {
            const next = nodes.find(n => n.id === conn.target);
            if (next && !visited.has(next.id) && !queue.includes(next)) {
                console.log(`‚û°Ô∏è Adding next node to queue: ${next.id}`);
                queue.push(next);
            }
        }
    }

    if (loop >= MAX) {
        console.error("‚ùå –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –∏—Ç–µ—Ä–∞—Ü–∏–π. –í–æ–∑–º–æ–∂–Ω—ã–π —Ü–∏–∫–ª –≤ workflow");
        console.log("üìä Final queue:", queue.map(n => n.id));
        console.log("‚úÖ Visited nodes:", Array.from(visited));
        console.log("üì¶ Results:", Object.keys(results));
    }

    // –§–∏–Ω–∞–ª—å–Ω—ã–π preview –¥–ª—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
    const outputPreview = Object.entries(results).map(([nodeId, ports]) => {
    const nodeInputs = nodeExecutionInputs[nodeId] || {};
    
    // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    let inputArray: INodeExecutionData[] = [];
    
    if (nodeInputs && typeof nodeInputs === 'object') {
        if (Array.isArray(nodeInputs)) {
            inputArray = nodeInputs;
        } else if (nodeInputs['input']) {
            // –î–ª—è –Ω–æ–¥ —Å –æ–¥–Ω–∏–º –≤—Ö–æ–¥–Ω—ã–º –ø–æ—Ä—Ç–æ–º
            inputArray = nodeInputs['input'];
        } else {
            // –î–ª—è multi-input –Ω–æ–¥
            Object.values(nodeInputs).forEach(portData => {
                if (Array.isArray(portData)) {
                    inputArray.push(...portData);
                }
            });
        }
    }
    
    // –ü–æ–ª—É—á–∞–µ–º –≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    const outputArray = Object.values(ports).flat();
    
    return {
        nodeId,
        data: {
            runData: {
                input: inputArray,
                output: outputArray,
                startTime: nodeExecutionTimes[nodeId]?.startTime || startTime,
                endTime: nodeExecutionTimes[nodeId]?.endTime || Date.now()
            }
        }
    };
});

    console.log("üßæ [Engine] –ó–∞–≤–µ—Ä—à–µ–Ω–æ.");
    console.log("üìä –°–æ–±—Ä–∞–Ω–æ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –Ω–æ–¥:", Object.keys(nodeExecutionInputs));
    
    return {
        outputPreview,
        finished: true,
        executedNodes: Array.from(visited),
        executionInputs: nodeExecutionInputs // –î–ª—è –æ—Ç–ª–∞–¥–∫–∏
    };
}

–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\nodeRegistry.ts:
// backend/nodeRegistry.ts
import path from "path";
import fs from "fs";
import { fileURLToPath } from "url";
import { INodeType } from "./types/nodes";

// ---------------------------------------------------------
// PATHS
// ---------------------------------------------------------

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const NODES_DIR = path.join(__dirname, "nodes");

// –†–µ–µ—Å—Ç—Ä –Ω–æ–¥: –∫–ª—é—á = description.name
const registry: Record<string, INodeType> = {};

let nodesLoaded = false; // —á—Ç–æ–±—ã –Ω–µ –∑–∞–≥—Ä—É–∂–∞—Ç—å –ø–æ–≤—Ç–æ—Ä–Ω–æ


// ---------------------------------------------------------
// ASYNC LOADER (new)
// ---------------------------------------------------------

/**
 * –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –∑–∞–≥—Ä—É–∂–∞–µ—Ç –≤—Å–µ *.node.ts / *.node.js —Ñ–∞–π–ª—ã
 * –∏ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π INodeType.
 */
export async function loadNodes(): Promise<void> {
  if (nodesLoaded) return;
  nodesLoaded = true;

  if (!fs.existsSync(NODES_DIR)) {
    console.warn("‚ö†Ô∏è Nodes directory does not exist:", NODES_DIR);
    return;
  }

  const files = fs.readdirSync(NODES_DIR);

  for (const file of files) {
    const lower = file.toLowerCase();
    if (!lower.endsWith(".node.ts") && !lower.endsWith(".node.js")) {
      continue;
    }

    const filePath = path.join(NODES_DIR, file);

    try {
      // ESM dynamic import ‚Äî –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ file://
      const module = await import(`file://${filePath}`);

      const node: INodeType = module.default;
      if (!node || !node.description?.name) {
        console.warn(`‚ö†Ô∏è Node file "${file}" does not export a valid INodeType`);
        continue;
      }

      const name = node.description.name;
      registry[name] = node;

      console.log(`üß© Registered node: ${name}`);
    } catch (err) {
      console.error(`‚ùå Failed to load node file "${file}":`, err);
    }
  }
}


// ---------------------------------------------------------
// LOAD IF NEEDED (called by server)
// ---------------------------------------------------------

export async function loadNodesIfNeeded() {
  if (!nodesLoaded) {
    await loadNodes();
  }
}


// ---------------------------------------------------------
// PUBLIC API
// ---------------------------------------------------------

export function getNodeType(type: string): INodeType | undefined {
  return registry[type];
}

export function getAllNodeDescriptions() {
  return Object.values(registry).map((node) => node.description);
}



–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\server.ts:
// backend/server.ts
import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import workflowRouter from "./routes/workflow";
import credentialsRouter from "./routes/credentials";
import credentialTypesRouter from "./routes/credentialTypes";
import { getAllNodeDescriptions, loadNodesIfNeeded } from "./nodeRegistry";

dotenv.config();

const PORT = Number(process.env.PORT || 3001);
const app = express();
app.use(cors({
  origin: 'http://localhost:5173', // –∏–ª–∏ –≤–∞—à —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ URL
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
app.use(express.json());
app.use("/api/credentials", credentialsRouter);      
app.use("/api/credential-types", credentialTypesRouter); 
// API: –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –Ω–æ–¥ (frontend Sidebar)
app.get("/api/nodes", (_req, res) => {
  try {
    const list = getAllNodeDescriptions();
    res.json(list);
  } catch (err) {
    res.status(500).json({ error: "Failed to get node list" });
  }
});

// workflow routes (expects routes/workflow.ts)
app.use("/api/workflow", workflowRouter);

// start server only after nodes loaded (if nodeRegistry requires async init)
async function start() {
  // –ï—Å–ª–∏ nodeRegistry —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç async loader ‚Äî –≤—ã–∑–æ–≤–µ–º –µ–≥–æ
  if (typeof loadNodesIfNeeded === "function") {
    await loadNodesIfNeeded();
  }

  app.listen(PORT, () => {
    console.log(`‚úÖ Backend running on port ${PORT}`);
  });
}

start().catch((err) => {
  console.error("Failed to start server:", err);
  process.exit(1);
});


–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\credentials\gigachatApi.credentials.ts:
import { ICredentialType } from "../types/credentials";

const gigachatApiCredentials: ICredentialType = {
  name: "gigachatApi",
  displayName: "GigaChat API Credential",
  properties: [
    {
      name: "clientId",
      displayName: "Client ID",
      type: "string",
      required: true,
      placeholder: "–í–≤–µ–¥–∏—Ç–µ client_id",
    },
    {
      name: "clientSecret",
      displayName: "Client Secret",
      type: "password",
      required: true,
      placeholder: "–í–≤–µ–¥–∏—Ç–µ client_secret",
    }
  ]
};

export default gigachatApiCredentials;


–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\helpers\expressionResolver.ts:
import { Parser } from "expr-eval";
import { IExecutionMap, IWorkflowNodeInstance } from "../types/workflow";

export function evalExpression(
  expression: string,
  context: {
    json?: Record<string, any>;
    itemIndex?: number;
    inputItems?: any[];
    executionResults?: IExecutionMap;
    nodes?: IWorkflowNodeInstance[];
    currentNodeId?: string;
    workflow?: { id?: string; name?: string };
    execution?: { id?: string; startedAt?: Date };
    env?: NodeJS.ProcessEnv;
    binary?: Record<string, any>;
  } = {}
): any {

  if (expression == null) return undefined;
  if (typeof expression !== "string") return expression;

  let clean = expression
    .replace(/^\s*{{\s*/, "")
    .replace(/\s*}}\s*$/, "")
    .trim();

  // $("node") -> $node("node")
  clean = clean.replace(/\$\(\s*['"`]([^'"`]+)['"`]\s*\)/g, '$node("$1")');

  // $json
  clean = clean.replace(/\$json\b/g, "json");

  // $env
  clean = clean.replace(/\$env\b/g, "env");

  // strict === -> ==
  clean = clean.replace(/===/g, "==");
  clean = clean.replace(/!==/g, "!=");

  const parser = new Parser({
    allowMemberAccess: true,
    operators: { in: true },
  });

  const json = context.json ?? {};
  const executionResults = context.executionResults ?? {};
  const nodes = context.nodes ?? [];
  const env = context.env ?? process.env;
  const inputItems = context.inputItems ?? [];
  const binary = context.binary ?? {};
  const currentNodeId = context.currentNodeId;
  const itemIndex = context.itemIndex ?? 0;

  function $node(nodeIdOrName: string) {
    const nodeInstance =
      nodes.find((n) => n.id === nodeIdOrName) ||
      nodes.find((n) => n.data?.displayName === nodeIdOrName) ||
      nodes.find((n) => n.data?.name === nodeIdOrName) ||
      nodes.find((n) => n.type === nodeIdOrName);

    const nodeId = nodeInstance ? nodeInstance.id : nodeIdOrName;
    const res = executionResults[nodeId] ?? {};

    const ports = Object.keys(res);
    const items: any[] = [];

    for (const port of ports) {
      if (Array.isArray(res[port])) {
        items.push(...res[port]);
      }
    }

    return {
      id: nodeId,
      node: nodeInstance,
      type: nodeInstance?.type,
      items,
      item: items?.[items.length - 1],
      first: () => items?.[0],
      last: () => items?.[items.length - 1],
      json: items?.[items.length - 1]?.json,
    };
  }

  function $prev(nodeNameOrId?: string) {
    if (!nodeNameOrId && nodes.length > 1) {
      const idx = nodes.findIndex((n) => n.id === currentNodeId);
      if (idx > 0) return $node(nodes[idx - 1].id);
    }
    return $node(nodeNameOrId || "");
  }

  const $input = {
    all: inputItems,
    items: inputItems,
    first: inputItems[0],
    last: inputItems[inputItems.length - 1],
    item: inputItems[itemIndex],
  };
  const currentNode = nodes.find(n => n.id === currentNodeId);
  const contextObj: Record<string, any> = {
    // Core
    json,
    env,

    // n8n
    $prev,
    $input,
    $node: currentNode,
    // Extra
    $workflow: context.workflow ?? {},
    $execution: context.execution ?? {},
    $binary: binary,
    $itemIndex: itemIndex,
    $nodeId: currentNodeId,

    // Utils
    $now: () => new Date(),
    length: (v: any) => (typeof v === "string" || Array.isArray(v) ? v.length : 0),
  };

  try {
    const value = parser.evaluate(clean, contextObj);
    return value;
  } catch (err: any) {
    console.warn("‚ùå Expression eval error:", err?.message, "expr:", clean);
    return undefined;
  }
}


–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\helpers\index.ts:
// backend/helpers/index.ts
import axios, { AxiosRequestConfig, AxiosResponse } from "axios";
import https from "https";
import { getDecryptedCredential } from "../services/credentialsStore";
import { IExecutionMap, IWorkflowNodeInstance } from "../types/workflow";
import { evalExpression } from "./expressionResolver";
export interface IHttpRequestOptions extends AxiosRequestConfig {
  /** –ü–æ–∑–≤–æ–ª—è–µ—Ç –æ—Ç–∫–ª—é—á–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É TLS —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞ */
  _insecureSkipTLS?: boolean;

  /** –õ–æ–≥–∏, –≤—ã–≤–æ–¥–∏–º—ã–µ –Ω–æ–¥–æ–π */
  debugLog?: (msg: string) => void;
}
export interface IExecutionContext {
  results: IExecutionMap;
  nodes: IWorkflowNodeInstance[];
}
export interface IHelpers {
  log: (message: string, ...args: any[]) => void;
  httpRequest: <T = any>(options: IHttpRequestOptions) => Promise<T>;
  getCredentials: (credentialId: string) => Promise<Record<string, any> | null>;

  executionContext?: {
    results: any;
    nodes: any[];
  };

  evaluateExpression: (expr: string, args: any) => any;   // üëà –í–û–¢ –≠–¢–û
}


/**
 * –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è.
 */
function makeLogger(context: string) {
  return (msg: string, ...args: any[]) => {
    console.log(`[${context}]`, msg, ...args);
  };
}

/**
 * –û–±—ë—Ä—Ç–∫–∞ –Ω–∞–¥ axios –±–µ–∑ —Å–∫—Ä—ã—Ç—ã—Ö —ç–≤—Ä–∏—Å—Ç–∏–∫
 */
async function httpRequest<T = any>(opts: IHttpRequestOptions): Promise<T> {
  const config: AxiosRequestConfig = {
    method: opts.method || "GET",
    url: opts.url,
    headers: opts.headers,
    params: opts.params,
    data: opts.data,
    timeout: opts.timeout ?? 30000,
  };

  // –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–æ–≤–µ—Ä–æ–∫ TLS ‚Äî –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ
  if (opts._insecureSkipTLS) {
    config.httpsAgent = new https.Agent({
      rejectUnauthorized: false,
    });
  }

  if (opts.debugLog) {
    opts.debugLog(`HTTP ‚Üí ${config.method} ${config.url}`);
    if (config.data) {
      const short = JSON.stringify(config.data).substring(0, 500);
      opts.debugLog(`Payload: ${short}`);
    }
  }

  try {
    const res: AxiosResponse<T> = await axios(config);
    return res.data;
  } catch (err: any) {
    const status = err?.response?.status;
    const body = err?.response?.data;
    const msg =
      status !== undefined
        ? `HTTP ${status}: ${JSON.stringify(body)}`
        : err?.message || String(err);

    throw new Error(msg);
  }
}

/**
 * –¢–µ–ø–µ—Ä—å credentials –±–µ—Ä—ë–º –∏–∑ credentialsStore.
 * –ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–æ–≤–º–µ—Å—Ç–∏–º–æ —Å –ø–æ–¥—Ö–æ–¥–æ–º n8n.
 */
async function getCredentials(
  credentialId: string
): Promise<Record<string, any> | null> {
  if (!credentialId) return null;

  try {
    const data = await getDecryptedCredential(credentialId);
    return data;
  } catch (err: any) {
    console.error("[Helpers] getCredentials error:", err.message);
    return null;
  }
}

/**
 * ‚úÖ –°–æ–∑–¥–∞—ë–º helpers –¥–ª—è –∫–∞–∂–¥–æ–π –Ω–æ–¥—ã
 * –ü–µ—Ä–µ–¥–∞—ë–º execution context (results + nodes), –∫–∞–∫ –≤ n8n
 */
export function createHelpers(
  context = "Engine",
  executionContext?: IExecutionContext
): IHelpers {
  const log = makeLogger(context);

  return {
  log,
  httpRequest: (opts) => httpRequest({ ...opts, debugLog: log }),
  getCredentials,
  executionContext,

  evaluateExpression: (expr, args) => {
    log("üîé evalExpression:", expr);
    return evalExpression(expr, args);
  },
};

}


–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\helpers\templateResolver.ts:
// backend/helpers/templateResolver.ts
import { evalExpression } from "./expressionResolver";
import { IExecutionMap, IWorkflowNodeInstance } from "../types/workflow";

/**
 * resolveTemplate(template, json, context)
 * - template: —Å—Ç—Ä–æ–∫–∞, –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å 0..N –≤—Ö–æ–∂–¥–µ–Ω–∏–π {{ ... }}
 * - json: –ª–æ–∫–∞–ª—å–Ω—ã–π $json (–¥–ª—è –ø—Ä–æ—Å—Ç—ã—Ö –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–æ–∫)
 * - context: { executionResults?, nodes?, env? }
 *
 * –ï—Å–ª–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏ {{ }} –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–µ-—Å—Ç—Ä–æ–∫—É, –¥–ª—è –ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤ —Ç–µ–∫—Å—Ç –º—ã
 * –ø—Ä–∏–≤–æ–¥–∏–º –∫ —Å—Ç—Ä–æ–∫–µ (JSON.stringify –¥–ª—è –æ–±—ä–µ–∫—Ç–æ–≤).
 */
export function resolveTemplate(
  template: string,
  json: Record<string, any> = {},
  context: {
    executionResults?: IExecutionMap;
    nodes?: IWorkflowNodeInstance[];
    env?: NodeJS.ProcessEnv;
  } = {}
): string {
  if (template == null || typeof template !== "string") return template;

  return template.replace(/\{\{\s*([\s\S]+?)\s*\}\}/g, (_full, expr) => {
    try {
      const val = evalExpression(expr, {
        json,
        executionResults: context.executionResults,
        nodes: context.nodes,
        env: context.env,
      });

      if (val === undefined || val === null) return "";
      if (typeof val === "string") return val;
      if (typeof val === "number" || typeof val === "boolean") return String(val);
      // For objects/arrays ‚Äî return JSON string
      return JSON.stringify(val);
    } catch (err) {
      console.warn("Template resolve error:", err);
      return "";
    }
  });
}


–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\nodes\EditFields.node.ts:
import { INodeType, IExecuteFunctions, IItem } from "../types/nodes";

const node: INodeType = {
  description: {
    name: "editFields",
    displayName: "‚úèÔ∏è Edit Fields",

    inputs: [{ id: "input", displayName: "Input" }],
    outputs: [{ id: "output", displayName: "Output" }],

    properties: [
      {
        name: "mode",
        type: "options",
        displayName: "Mode",
        options: [
          { name: "Raw JSON", value: "json" },
        ],
        default: "json",
      },
      {
        name: "jsonValue",
        type: "string",
        displayName: "JSON",
        default: '{\n  "text": "hello"\n}',
        placeholder: '{ "example": "value" }',
        typeOptions: { multiline: true },
      },
    ],
  },

  async execute(this: IExecuteFunctions): Promise<IItem[]> {
    const inputItems = this.getInputData("input");

    // –ï—Å–ª–∏ –Ω–µ—Ç –≤—Ö–æ–¥–∞ ‚Äî —Å–æ–∑–¥–∞—ë–º 1 –ø—É—Å—Ç–æ–π item (–ø–æ—Å–ª–µ ManualTrigger)
    const itemsToProcess: IItem[] =
      inputItems.length > 0
        ? inputItems
        : [{ json: {} }];

    const result: IItem[] = [];

    for (let i = 0; i < itemsToProcess.length; i++) {
      const item = itemsToProcess[i];

      const mode = this.getNodeParameter("mode", i, "json") as string;

      if (mode === "json") {
        const rawValue = this.getNodeParameter("jsonValue", i, "{}");

        if (typeof rawValue !== "string") {
          throw new Error("JSON value must be a string");
        }

        try {
          const parsed = JSON.parse(rawValue);

          result.push({
            json: parsed,
          });
        } catch (err: any) {
          throw new Error(
            `Invalid JSON in Edit Fields (item ${i}): ${err.message}`
          );
        }
      }
    }

    this.helpers.log(`‚úÖ EditFields produced ${result.length} items`);
    return result;
  },
};

export default node;


–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\nodes\GigaChat.node.ts:
// backend/nodes/GigaChat.node.ts
import { INodeType, IItem, IExecuteFunctions } from "../types/nodes";
import { v4 as uuidv4 } from 'uuid';

const OAUTH_URL = "https://ngw.devices.sberbank.ru:9443/api/v2/oauth";
const CHAT_URL = "https://gigachat.devices.sberbank.ru/api/v1/chat/completions";

let _cachedToken: string | null = null;
let _tokenExpiry = 0;

async function obtainToken(
  clientId: string,
  clientSecret: string,
  helpers: any
): Promise<string> {
  const now = Date.now();
  if (_cachedToken && now < _tokenExpiry) {
    helpers.log("GigaChat: using cached token");
    return _cachedToken;
  }

  const cleanClientId = clientId.trim();
  const cleanClientSecret = clientSecret.trim();
  
  helpers.log(`GigaChat: clientId length: ${cleanClientId.length}`);
  helpers.log(`GigaChat: clientSecret length: ${cleanClientSecret.length}`);

  const authString = `${cleanClientId}:${cleanClientSecret}`;
  const credsBasic = Buffer.from(authString).toString("base64");
  
  helpers.log(`GigaChat: auth string: ${cleanClientId}:***`);
  helpers.log(`GigaChat: base64 length: ${credsBasic.length}`);

  try {
    const response = await helpers.httpRequest({
      method: "POST",
      url: OAUTH_URL,
      headers: {
        Authorization: `Basic ${credsBasic}`,
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "application/json",
        "RqUID": uuidv4(), // –ò—Å–ø–æ–ª—å–∑—É–µ–º UUID v4
      },
      data: "scope=GIGACHAT_API_PERS",
      _insecureSkipTLS: true,
      timeout: 15000,
    });

    helpers.log(`GigaChat: OAuth response received`);
    
    const token = response?.access_token;
    if (!token) {
      helpers.log(`GigaChat: No access_token in response:`, JSON.stringify(response, null, 2));
      throw new Error("No access_token in OAuth response");
    }

    const expiresIn = response?.expires_in || 1800;
    _tokenExpiry = Date.now() + expiresIn * 1000 - 60000;
    _cachedToken = token;

    helpers.log(`GigaChat: Token obtained, expires in ${expiresIn}s`);
    return token;
  } catch (err: any) {
    helpers.log(`GigaChat: OAuth error details:`);
    helpers.log(`  - Status: ${err.response?.status}`);
    helpers.log(`  - Status Text: ${err.response?.statusText}`);
    helpers.log(`  - Headers: ${JSON.stringify(err.response?.headers)}`);
    helpers.log(`  - Data: ${JSON.stringify(err.response?.data)}`);
    helpers.log(`  - Message: ${err.message}`);
    
    if (err.response?.status === 400 || err.response?.status === 401) {
      throw new Error("Authentication failed. Please check your Client ID and Client Secret.");
    } else {
      throw new Error(`GigaChat API error: ${err.response?.status || 'Unknown status'} - ${err.message}`);
    }
  }
}


async function callChatApi(
  token: string,
  prompt: string,
  model: string,
  temperature: number,
  helpers: any
) {
  try {
    const response = await helpers.httpRequest({
      method: "POST",
      url: CHAT_URL,
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      data: {
        model,
        messages: [{ role: "user", content: prompt }],
        temperature,
        max_tokens: 1000,
        stream: false,
      },
      _insecureSkipTLS: true,
      timeout: 30000,
    });

    return response;
  } catch (err: any) {
    const body = err?.response?.data ?? err?.message ?? err;
    throw new Error("GigaChat API error: " + (typeof body === "string" ? body : JSON.stringify(body)));
  }
}

function mockResponse(prompt: string) {
  return `MOCK: –æ—Ç–≤–µ—Ç –Ω–∞ "${String(prompt).slice(0, 120)}" (no credentials)`;
}

const node: INodeType = {
  description: {
    name: "gigachat_chat",
    displayName: "ü§ñ GigaChat",
    inputs: [ { id: "input", displayName: "–í—Ö–æ–¥" } ], 
    outputs: [ { id: "output", displayName: "–í—ã—Ö–æ–¥" } ],

    credentials: [
      {
        name: "gigachatApi",
        required: true
      }
    ],
    properties: [
      {
        name: "credentialId", // –í —ç—Ç–æ –ø–æ–ª–µ –∑–∞–ø–∏—à–µ—Ç—Å—è ID –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –∫–ª—é—á–∞
        type: "credentials",
        displayName: "–£—á–µ—Ç–Ω–∞—è –∑–∞–ø–∏—Å—å",
        default: "",
        // –í–∞–∂–Ω–æ: —É–∫–∞–∑—ã–≤–∞–µ–º, –∫–∞–∫–æ–π —Ç–∏–ø –∫–ª—é—á–µ–π –∑–¥–µ—Å—å –Ω—É–∂–µ–Ω
        typeOptions: {
          credentialType: "gigachatApi" 
        } 
      },
      {
        name: "prompt",
        type: "string",
        displayName: "–ü—Ä–æ–º–ø—Ç",
        default: "–û—Ç–≤–µ—Ç—å –Ω–∞ –≤–æ–ø—Ä–æ—Å: {{ $json.text }}",
        typeOptions: { multiline: true },
      },
      {
        name: "model",
        type: "options",
        displayName: "–ú–æ–¥–µ–ª—å",
        default: "GigaChat",
        options: [
          { name: "GigaChat", value: "GigaChat" },
          { name: "GigaChat-Plus", value: "GigaChat-Plus" },
          { name: "GigaChat-Pro", value: "GigaChat-Pro" },
        ],
      },
      {
        name: "temperature",
        type: "number",
        displayName: "–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞",
        default: 0.7,
        typeOptions: { min: 0, max: 1, step: 0.1 },
      },
    ],
  },

  async execute(this: IExecuteFunctions): Promise<IItem[]> {
    // 1. –ü–æ–ª—É—á–∞–µ–º –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç
    
    let items = this.getInputData("input");
    if (items.length === 0) {
      items = [{ json: {} }];
    }
    const out: IItem[] = [];

    // 2. –ü–æ–ª—É—á–∞–µ–º credentials
    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã, –Ω–µ –∑–∞–≤–∏—Å—è—â–∏–µ –æ—Ç item-–∞ (–∫–∞–∫ credentialId), –º–æ–∂–Ω–æ –±—Ä–∞—Ç—å –ø–æ –∏–Ω–¥–µ–∫—Å—É 0
    const credentialId = this.getNodeParameter("credentialId", 0) as string;
    
    let creds: Record<string, any> | null | undefined = undefined;
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º this.helpers
    if (credentialId && this.helpers.getCredentials) {
      try {
        creds = await this.helpers.getCredentials(credentialId);
      } catch {
        creds = undefined;
      }
    }

    const envClientId = process.env.GIGACHAT_CLIENT_ID;
    const envClientSecret = process.env.GIGACHAT_CLIENT_SECRET;

    const clientId = creds?.clientId ?? creds?.client_id ?? envClientId;
    const clientSecret = creds?.clientSecret ?? creds?.client_secret ?? envClientSecret;

    this.helpers.log(`GigaChat: Final clientId: ${clientId ? `${clientId.substring(0, 8)}...` : 'MISSING'}`);
    
    this.helpers.log(`GigaChat node: processing ${items.length} items`);

    // 3. –ò—Ç–µ—Ä–∏—Ä—É–µ–º—Å—è –ø–æ –∏–Ω–¥–µ–∫—Å–∞–º, —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∏ –Ω—É–∂–Ω—ã –¥–ª—è getNodeParameter
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      
      try {
        // === –ú–ê–ì–ò–Ø SMART CONTEXT ===
        // –ú—ã –ø—Ä–æ—Å–∏–º –¥–≤–∏–∂–æ–∫ –¥–∞—Ç—å –Ω–∞–º –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–∞ —Å –∏–Ω–¥–µ–∫—Å–æ–º i.
        // –î–≤–∏–∂–æ–∫ —Å–∞–º –Ω–∞–π–¥–µ—Ç {{ $json... }}, –≤—ã—á–∏—Å–ª–∏—Ç –µ–≥–æ –∏ –≤–µ—Ä–Ω–µ—Ç —Å—Ç—Ä–æ–∫—É.
        const prompt = this.getNodeParameter("prompt", i) as string;
        const model = this.getNodeParameter("model", i, "GigaChat") as string;
        const temperature = this.getNodeParameter("temperature", i, 0.7) as number;

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—É—Å—Ç–æ—Ç—É (resolveTemplate –±–æ–ª—å—à–µ –Ω–µ –Ω—É–∂–µ–Ω)
        if (!prompt || String(prompt).trim() === "") {
          this.helpers.log("GigaChat: empty prompt, skipping");
          out.push({
            json: { ...item.json, response: "Empty prompt", error: true },
          });
          continue;
        }

        let responseText = "";
        let usage = {};
        let usedModel = model;

        if (!clientId || !clientSecret) {
          this.helpers.log("GigaChat: credentials missing -> mock mode");
          // –§—É–Ω–∫—Ü–∏—è mockResponse –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –≤—ã—à–µ –≤ —Ñ–∞–π–ª–µ –∏–ª–∏ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–∞
          // responseText = mockResponse(prompt); 
          responseText = `MOCK: –æ—Ç–≤–µ—Ç –Ω–∞ "${prompt}" (no credentials)`;
          usedModel = "mock";
        } else {
          try {
            // –ü–µ—Ä–µ–¥–∞–µ–º this.helpers –≤ –≤–∞—à–∏ –≤–Ω–µ—à–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏
            const token = await obtainToken(clientId, clientSecret, this.helpers);
            const apiResp = await callChatApi(token, prompt, model, temperature, this.helpers);
            
            responseText = apiResp?.choices?.[0]?.message?.content ?? String(apiResp);
            usage = apiResp?.usage ?? {};
            usedModel = apiResp?.model ?? model;
          } catch (err: any) {
            this.helpers.log("GigaChat: API error:", err?.message ?? err);
            responseText = `GigaChat error: ${err?.message ?? String(err)}`;
          }
        }

        out.push({
          json: {
            ...item.json,
            prompt, // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã—á–∏—Å–ª–µ–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç
            response: responseText,
            model: usedModel,
            usage,
            timestamp: new Date().toISOString(),
          },
        });
      } catch (err: any) {
        this.helpers.log("GigaChat: processing error:", err?.message ?? err);
        out.push({
          json: {
            ...item.json,
            response: `Processing error: ${err?.message ?? String(err)}`,
            error: true,
            timestamp: new Date().toISOString(),
          },
        });
      }
    }

    return out;
  },
};

export default node;


–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\nodes\If.node.ts:
// backend/nodes/If.node.ts

import { INodeDefinition, IItem, IExecuteFunctions } from "../types/nodes";

const IfNode: INodeDefinition = {
  description: {
    name: "if",
    displayName: "üö¶ –£—Å–ª–æ–≤–∏–µ (IF)",

    inputs: [{ id: "input", displayName: "–í—Ö–æ–¥" }],
    outputs: [
      { id: "output_true", displayName: "True" },
      { id: "output_false", displayName: "False" },
    ],

    properties: [
      {
        name: "condition",
        type: "string",
        displayName: "–£—Å–ª–æ–≤–∏–µ",
        default: '{{ $json.text === "hello" }}',
        placeholder: "–ù–∞–ø—Ä–∏–º–µ—Ä: {{ $json.field === 'value' }}",
        description:
          "–í—ã—Ä–∞–∂–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –±—É–¥–µ—Ç –≤—ã—á–∏—Å–ª–µ–Ω–æ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≤—Ö–æ–¥–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞",
      },
    ],
  },

  async execute(this: IExecuteFunctions): Promise<Record<string, IItem[]>> {
    let items = this.getInputData("input");
    if (items.length === 0) {
        items = [{ json: {} }];
    }

    const output_true: IItem[] = [];
    const output_false: IItem[] = [];

    this.helpers.log(`[IF] üì¶ Items count: ${items.length}`);

    for (let i = 0; i < items.length; i++) {
      const item = items[i];

      this.helpers.log(`üß™ [IF] item[${i}].json = ${JSON.stringify(item.json)}`);

      let conditionResult = false;

      try {
        const value = this.getNodeParameter("condition", i, false);
        conditionResult = Boolean(value);

        this.helpers.log(
          `üß† [IF] Eval result for item ${i}: ${value} ‚Üí ${conditionResult ? "TRUE" : "FALSE"}`
        );
      } catch (error: any) {
        this.helpers.log(
          `‚ùå [IF] Condition error on item ${i}: ${error?.message ?? error}`
        );
        conditionResult = false;
      }

      if (conditionResult) {
        output_true.push(item);
      } else {
        output_false.push(item);
      }
    }

    this.helpers.log(`‚úÖ [IF] TRUE items: ${output_true.length}`);
    this.helpers.log(`‚úÖ [IF] FALSE items: ${output_false.length}`);

    return {
      output_true,
      output_false,
    };
  },
};

export default IfNode;


–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\nodes\Input.node.ts:
// backend/nodes/Input.node.ts
import { INodeType, IItem, IExecuteFunctions } from "../types/nodes";

const node: INodeType = {
  description: {
    name: "input",
    displayName: "üü¢ Input",
    inputs: [], 
    outputs: [ { id: "output", displayName: "–í—ã—Ö–æ–¥" } ],
    properties: [
      {
        name: "text",
        type: "string",
        displayName: "–í—Ö–æ–¥–Ω–æ–π —Ç–µ–∫—Å—Ç",
        default: "",
        placeholder: "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç...",
        typeOptions: { multiline: true },
      },
    ],
  },

  async execute(this: IExecuteFunctions): Promise<IItem[]> {
    // Input ‚Äî —ç—Ç–æ —Å—Ç–∞—Ä—Ç–æ–≤–∞—è –Ω–æ–¥–∞. –£ –Ω–µ—ë –Ω–µ—Ç –≤—Ö–æ–¥—è—â–∏—Ö items.
    // –ú—ã –ø—Ä–æ—Å—Ç–æ —á–∏—Ç–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏.
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∏–Ω–¥–µ–∫—Å 0, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ —Å–æ–∑–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å –Ω—É–ª—è.
    const text = this.getNodeParameter("text", 0, "") as string;
    
    this.helpers.log(`Input node: returning text "${String(text).slice(0, 120)}"`);
    
    return [{ json: { text } }];
  },
};

export default node;


–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\nodes\ManualTrigger.node.ts:
import { INodeType, IExecuteFunctions, IItem } from "../types/nodes";

const node: INodeType = {
  description: {
    name: "manualTrigger",
    displayName: "üëÜ Manual Trigger",

    inputs: [],

    // –ï–°–¢–¨ 1 –≤—ã—Ö–æ–¥
    outputs: [{ id: "output", displayName: "Output" }],

    // –í–ê–ñ–ù–û –¥–ª—è –¥–≤–∏–∂–∫–∞
    trigger: true,

    properties: [
      {
        name: "notice",
        type: "string",
        displayName: "Info",
        default: "This node starts the workflow when you click Test.",
        typeOptions: { multiline: true }
      }
    ],
  },

  async execute(this: IExecuteFunctions): Promise<IItem[]> {
    this.helpers.log("üöÄ Manual Trigger fired");

    // –ó–∞–ø—É—Å–∫ —Ü–µ–ø–∏ —Å –ø—É—Å—Ç—ã–º –æ–±—ä–µ–∫—Ç–æ–º
    return [
      {
        json: {
          startedAt: new Date().toISOString(),
        },
      },
    ];
  },
};

export default node;


–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\nodes\Output.node.ts:
// backend/nodes/Output.node.ts
import { INodeType, IExecuteFunctions, IItem } from "../types/nodes";

const node: INodeType = {
  description: {
    name: "output",
    displayName: "üì§ Output",
    inputs: [{ id: "input", displayName: "–í—Ö–æ–¥" }],
    outputs: [],
    properties: [
  {
    name: "mode",
    type: "options",
    displayName: "–†–µ–∂–∏–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è",
    default: "json",
    options: [
      { name: "JSON", value: "json" },
      { name: "Text", value: "text" },
      { name: "Count only", value: "count" }
    ]
  },
  {
    name: "preview",
    type: "string",
    displayName: "–†–µ–∑—É–ª—å—Ç–∞—Ç",
    default: "",
    typeOptions: {
      rows: 8,
      readOnly: true
    }
  }
    ]

  },

  async execute(this: IExecuteFunctions): Promise<IItem[]> {
    const startTime = Date.now();
    const items = this.getInputData("input");
    const mode = this.getNodeParameter("mode", 0) as string;

    let output = "";

    if (!items || items.length === 0) {
      return [{
        json: {
          _system: "No input data"
        },
        meta: {
          preview: ""
        }
      }];
    }

    switch (mode) {
      case "text":
        output = items
          .map(i => i.json?.text ?? JSON.stringify(i.json))
          .join("\n");
        break;

      case "count":
        output = `–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤: ${items.length}`;
        break;

      case "json":
      default:
        output = JSON.stringify(
          items.map(i => i.json),
          null,
          2
        );
    }

    return items.map((item, index) => ({
      json: item.json,
      meta: {
        index,
        preview: ""
      }
    }));
  }
};

export default node;


–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\routes\credentials.ts:
// backend/routes/credentials.ts - –¥–æ–±–∞–≤—å—Ç–µ DELETE endpoint
import express from "express";
import { listCredentials, saveCredential, deleteCredential } from "../services/credentialsStore";

const router = express.Router();

/** GET /api/credentials ‚Äî —Å–ø–∏—Å–æ–∫ credentials */
router.get("/", async (_req, res) => {
  try {
    const list = await listCredentials();
    res.json(list);
  } catch (err: any) {
    res.status(500).json({ error: err.message });
  }
});

/** POST /api/credentials ‚Äî —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π */
router.post("/", async (req, res) => {
  try {
    const { name, type, data } = req.body;

    if (!name || !type || !data)
      return res.status(400).json({ error: "Missing fields" });

    const created = await saveCredential(name, type, data);

    res.json({ id: created.id, name: created.name });
  } catch (err: any) {
    res.status(500).json({ error: err.message });
  }
});

/** DELETE /api/credentials/:id ‚Äî —É–¥–∞–ª–∏—Ç—å credential */
router.delete("/:id", async (req, res) => {
  try {
    const { id } = req.params;
    
    if (!id) {
      return res.status(400).json({ error: "Credential ID is required" });
    }

    const success = await deleteCredential(id);
    
    if (!success) {
      return res.status(404).json({ error: "Credential not found" });
    }
    
    res.json({ 
      success: true, 
      message: `Credential ${id} deleted` 
    });
  } catch (err: any) {
    console.error("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è credential:", err);
    res.status(500).json({ 
      error: err.message || "Internal server error" 
    });
  }
});

export default router;

–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\routes\credentialTypes.ts:
// backend/routes/credentialTypes.ts
import express from 'express';
import { listCredentialTypes } from '../services/credentialTypeRegistry';
import { getErrorMessage } from '../utils/errorHandler';

const router = express.Router();

router.get('/', async (req, res) => {
  try {
    const types = await listCredentialTypes();
    res.json(types);
  } catch (error) {
    console.error("Error listing credential types:", error);
    res.status(500).json({ 
      error: "Failed to load credential types", 
      details: getErrorMessage(error)
    });
  }
});

export default router;

–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\routes\workflow.ts:
// backend/routes/workflow.ts
import express, { Request, Response } from "express";
import { executeWorkflow } from "../executionEngine";
import {
  IWorkflowNodeInstance,
  IWorkflowConnection,
  IWorkflowSchema,
  IWorkflowListItem
} from "../types/workflow";
import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const WORKFLOWS_DIR = path.join(__dirname, "..", "workflows");


// –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ backend
(async () => {
  try {
    await fs.mkdir(WORKFLOWS_DIR, { recursive: true });
    console.log(`üóÇ Workflows directory ensured at: ${WORKFLOWS_DIR}`);
  } catch (e) {
    console.error("‚ùå Error creating workflows directory:", e);
  }
})();

const router = express.Router();

/* ============================================================
   1. RUN WORKFLOW
   ============================================================ */
router.post(
  "/run",
  async (
    req: Request<
      any,
      any,
      { nodes: IWorkflowNodeInstance[]; edges: IWorkflowConnection[] }
    >,
    res: Response
  ) => {
    const { nodes, edges } = req.body;

    if (!nodes || !edges) {
      return res.status(400).json({
        error: "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞. –¢—Ä–µ–±—É—é—Ç—Å—è 'nodes' –∏ 'edges'."
      });
    }

    try {
      const result = await executeWorkflow(nodes, edges);
      res.json(result);
    } catch (error: any) {
      console.error("‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å—Ö–µ–º—ã:", error);
      res.status(500).json({
        error: "–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞",
        details: error.message
      });
    }
  }
);

/* ============================================================
   2. SAVE WORKFLOW
   ============================================================ */
router.post(
  "/save",
  async (
    req: Request<
      any,
      any,
      { name: string; nodes: IWorkflowNodeInstance[]; edges: IWorkflowConnection[] }
    >,
    res: Response
  ) => {
    const { name, nodes, edges } = req.body;

    if (!name || !nodes || !edges) {
      return res.status(400).json({
        error: "–ù–µ–æ–±—Ö–æ–¥–∏–º—ã 'name', 'nodes' –∏ 'edges'."
      });
    }

    const workflowId = `${name.toLowerCase().replace(/\s+/g, "-")}-${Date.now()}`;
    const filePath = path.join(WORKFLOWS_DIR, `${workflowId}.json`);

    const schema: IWorkflowSchema = {
      id: workflowId,
      name,
      nodes,
      edges,
      meta: {
        savedAt: new Date().toISOString()
      }
    };

    try {
      await fs.writeFile(filePath, JSON.stringify(schema, null, 2));
      console.log(`üíæ –°—Ö–µ–º–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: ${workflowId}`);
      res.json({ message: "–°—Ö–µ–º–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞", id: workflowId });
    } catch (error) {
      console.error("‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ö–µ–º—ã:", error);
      res.status(500).json({ error: "–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞" });
    }
  }
);

/* ============================================================
   3. LOAD WORKFLOW
   ============================================================ */
router.get(
  "/load/:id",
  async (req: Request<{ id: string }>, res: Response) => {
    const { id } = req.params;
    const safeId = path.basename(id);
    const filePath = path.join(WORKFLOWS_DIR, `${safeId}.json`);

    try {
      const raw = await fs.readFile(filePath, "utf-8");
      const schema: IWorkflowSchema = JSON.parse(raw);

      console.log(`üìÇ –°—Ö–µ–º–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞: ${id}`);
      res.json(schema);
    } catch (error: any) {
      console.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ö–µ–º—ã:", error);

      if (error.code === "ENOENT") {
        return res.status(404).json({ error: "–°—Ö–µ–º–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
      }

      res.status(500).json({ error: "–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞" });
    }
  }
);

/* ============================================================
   4. LIST ALL WORKFLOWS
   ============================================================ */
router.get(
  "/list",
  async (_req: Request, res: Response) => {
    try {
      const files = await fs.readdir(WORKFLOWS_DIR);
      const workflows: IWorkflowListItem[] = [];
      
      for (const file of files) {
        if (!file.endsWith(".json")) continue;
        
        const filePath = path.join(WORKFLOWS_DIR, file);
        try {
          const raw = await fs.readFile(filePath, "utf-8");
          const schema: IWorkflowSchema = JSON.parse(raw);
          
          // –î–æ–±–∞–≤–ª—è–µ–º —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –Ω–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
          if (schema.id && schema.name) {
            workflows.push({
              id: schema.id,
              name: schema.name,
              savedAt: schema.meta?.savedAt || new Date().toISOString(),
              nodesCount: schema.nodes?.length || 0,
              edgesCount: schema.edges?.length || 0
            });
          } else {
            console.warn(`‚ö†Ô∏è Workflow file ${file} missing id or name`);
          }
        } catch (readErr) {
          console.warn(`‚ö†Ô∏è Could not read workflow file ${file}:`, readErr);
        }
      }
      
      // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –¥–∞—Ç–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è (–Ω–æ–≤—ã–µ —Å–≤–µ—Ä—Ö—É)
      workflows.sort((a: IWorkflowListItem, b: IWorkflowListItem) => {
        const dateA = a.savedAt ? new Date(a.savedAt).getTime() : 0;
        const dateB = b.savedAt ? new Date(b.savedAt).getTime() : 0;
        return dateB - dateA;
      });
      
      console.log(`üìã –û—Ç–ø—Ä–∞–≤–ª–µ–Ω —Å–ø–∏—Å–æ–∫ —Å—Ö–µ–º: ${workflows.length} —à—Ç.`);
      res.json(workflows);
    } catch (error: any) {
      console.error("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ —Å—Ö–µ–º:", error);
      res.status(500).json({ error: "–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ —Å—Ö–µ–º" });
    }
  }
);

/* ============================================================
   5. DELETE WORKFLOW
   ============================================================ */
router.delete(
  "/:id",
  async (req: Request<{ id: string }>, res: Response) => {
    const { id } = req.params;
    const safeId = path.basename(id);
    const filePath = path.join(WORKFLOWS_DIR, `${safeId}.json`);
    
    try {
      await fs.access(filePath); // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
      await fs.unlink(filePath);
      console.log(`üóëÔ∏è –°—Ö–µ–º–∞ —É–¥–∞–ª–µ–Ω–∞: ${id}`);
      res.json({ success: true, message: "–°—Ö–µ–º–∞ —É–¥–∞–ª–µ–Ω–∞" });
    } catch (error: any) {
      console.error("‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å—Ö–µ–º—ã:", error);
      if (error.code === "ENOENT") {
        return res.status(404).json({ error: "–°—Ö–µ–º–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞" });
      }
      res.status(500).json({ error: "–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞" });
    }
  }
);

export default router;

–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\services\credentialsStore.ts:
// backend/services/credentialsStore.ts
import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from "url";
import { IStoredCredential } from "../types/credentials";
import { encrypt, decrypt } from "./encryption";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// credentials.json —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ –∫–æ—Ä–Ω–µ backend
const CREDENTIALS_FILE = path.join(__dirname, "..", "..", "credentials.json");

async function readCredentialsFile(): Promise<IStoredCredential[]> {
  try {
    const data = await fs.readFile(CREDENTIALS_FILE, "utf8");
    return JSON.parse(data);
  } catch {
    return [];
  }
}

async function writeCredentialsFile(data: IStoredCredential[]) {
  await fs.writeFile(CREDENTIALS_FILE, JSON.stringify(data, null, 2));
}

/** –°–ø–∏—Å–æ–∫ credentials –¥–ª—è UI */
export async function listCredentials() {
  const all = await readCredentialsFile();
  return all.map((c) => ({
    id: c.id,
    name: c.name,
    type: c.type,
    createdAt: c.createdAt,
  }));
}

/** –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –Ω–æ–≤—ã–π credentials */
export async function saveCredential(
  name: string,
  type: string,
  data: Record<string, any>
) {
  const all = await readCredentialsFile();

  const encryptedData: Record<string, any> = {};
  for (const [key, value] of Object.entries(data)) {
    encryptedData[key] = typeof value === "string" ? encrypt(value) : value;
  }

  const newItem: IStoredCredential = {
    id: Date.now().toString(),
    name,
    type,
    data: encryptedData,
    createdAt: new Date().toISOString(),
  };

  all.push(newItem);
  await writeCredentialsFile(all);

  return newItem;
}

/** –ü–æ–ª—É—á–∏—Ç—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π credentials */
export async function getDecryptedCredential(
  id: string
): Promise<Record<string, any> | null> {
  const all = await readCredentialsFile();
  const found = all.find((c) => c.id === id);
  if (!found) return null;

  const decrypted: Record<string, any> = {};
  for (const [key, value] of Object.entries(found.data)) {
    if (typeof value === "string") {
      try {
        decrypted[key] = decrypt(value);
      } catch {
        decrypted[key] = value; // fallback
      }
    } else {
      decrypted[key] = value;
    }
  }

  return decrypted;
}

/** –£–¥–∞–ª–∏—Ç—å credentials */
export async function deleteCredential(id: string): Promise<boolean> {
  try {
    const all = await readCredentialsFile();
    const initialLength = all.length;
    
    const filtered = all.filter((c) => c.id !== id);
    
    if (filtered.length === initialLength) {
      return false; // credential –Ω–µ –Ω–∞–π–¥–µ–Ω
    }
    
    await writeCredentialsFile(filtered);
    return true;
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è credential:", error);
    throw error;
  }
}

–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\services\credentialTypeRegistry.ts:
// backend/services/credentialTypeRegistry.ts
import fs from "fs/promises";
import path from "path";
import { fileURLToPath, pathToFileURL } from "url"; // –î–æ–±–∞–≤—å—Ç–µ pathToFileURL
import { ICredentialType } from "../types/credentials";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const CREDENTIALS_DIR = path.join(__dirname, "..", "credentials");

/**
 * –ö—ç—à –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö credential types (–∫–∞–∫ –≤ n8n)
 */
const credentialTypesCache: Map<string, ICredentialType> = new Map();

/**
 * –ó–∞–≥—Ä—É–∂–∞–µ—Ç –≤—Å–µ —Ñ–∞–π–ª—ã –≤ –ø–∞–ø–∫–µ /credentials
 */
export async function loadCredentialTypes() {
  try {
    const files = await fs.readdir(CREDENTIALS_DIR);
    
    for (const file of files) {
      if (!file.endsWith('.ts') && !file.endsWith('.js')) continue;
      
      const fullPath = path.join(CREDENTIALS_DIR, file);
      console.log(`Loading credential from: ${fullPath}`);
      
      try {
        // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º pathToFileURL –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –ø—É—Ç–∏ –≤ file:// URL
        const fileUrl = pathToFileURL(fullPath).href;
        const mod = await import(fileUrl);
        
        const cred = mod.default || mod.credential || null;
        
        if (cred && cred.name) {
          credentialTypesCache.set(cred.name, cred);
          console.log(`‚úÖ Registered credential type: ${cred.name}`);
        } else {
          console.warn(`‚ö†Ô∏è Credential file missing name or default export: ${file}`);
        }
      } catch (importError) {
        console.error(`‚ùå Failed to import ${file}:`, importError);
        
        // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ —Å require (–¥–ª—è CommonJS)
        try {
          console.log(`üîÑ Trying require fallback for ${file}`);
          const mod = require(fullPath);
          const cred = mod.default || mod.credential || mod;
          
          if (cred && cred.name) {
            credentialTypesCache.set(cred.name, cred);
            console.log(`‚úÖ Registered credential type (via require): ${cred.name}`);
          }
        } catch (requireError) {
          console.error(`‚ùå Require fallback also failed for ${file}:`, requireError);
        }
      }
    }
  } catch (dirError) {
    console.error('‚ùå Error reading credentials directory:', dirError);
  }
}

/**
 * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –º–∞—Å—Å–∏–≤ –≤—Å–µ—Ö credential types –¥–ª—è UI
 */
export async function listCredentialTypes(): Promise<ICredentialType[]> {
  if (credentialTypesCache.size === 0) {
    await loadCredentialTypes();
  }
  return Array.from(credentialTypesCache.values());
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ –ø–æ –∏–º–µ–Ω–∏
 */
export function getCredentialType(name: string): ICredentialType | undefined {
  return credentialTypesCache.get(name);
}

–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\services\encryption.ts:
// backend/services/encryption.ts
import crypto from "crypto";
import dotenv from "dotenv";

dotenv.config();

const ALGORITHM = "aes-256-cbc";

/**
 * –ö–ª—é—á —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 32 –±–∞–π—Ç–∞.
 * –ï—Å–ª–∏ .env –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç ENCRYPTION_KEY ‚Üí –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π,
 * –Ω–æ –ø–æ—Å–ª–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ –≤—Å–µ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å—Ç–∞–Ω—É—Ç –Ω–µ—á–∏—Ç–∞–µ–º—ã–º–∏.
 */
const SECRET_KEY = process.env.ENCRYPTION_KEY
  ? crypto.createHash("sha256")
      .update(String(process.env.ENCRYPTION_KEY))
      .digest()
  : crypto.randomBytes(32);

const IV_LENGTH = 16;

/** –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ */
export function encrypt(value: string): string {
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv(ALGORITHM, SECRET_KEY, iv);

  const encrypted = Buffer.concat([cipher.update(value, "utf8"), cipher.final()]);
  return iv.toString("hex") + ":" + encrypted.toString("hex");
}

/** –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ —Å—Ç—Ä–æ–∫–∏ */
export function decrypt(encrypted: string): string {
  const [ivHex, contentHex] = encrypted.split(":");
  if (!ivHex || !contentHex) throw new Error("Invalid encrypted format");

  const iv = Buffer.from(ivHex, "hex");
  const encryptedData = Buffer.from(contentHex, "hex");

  const decipher = crypto.createDecipheriv(ALGORITHM, SECRET_KEY, iv);
  const decrypted = Buffer.concat([decipher.update(encryptedData), decipher.final()]);

  return decrypted.toString("utf8");
}


–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\types\credentials.ts:
/**
 * –û–¥–Ω–æ –ø–æ–ª–µ —Ñ–æ—Ä–º—ã Credential Type (–∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ n8n INodeProperties)
 * –û–ø–∏—Å—ã–≤–∞–µ—Ç, –∫–∞–∫–∏–µ –ø–æ–ª—è –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ UI –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–ª—é—á–∞.
 */
export interface ICredentialProperty {
  name: string;
  displayName: string;
  type: "string" | "number" | "password" | "boolean";
  default?: any;
  placeholder?: string;
  description?: string;
  required?: boolean;
}

/**
 * Credential Type ‚Äî –æ–ø–∏—Å–∞–Ω–∏–µ —Ç–∏–ø–∞ –∫–ª—é—á–∞ (–∞–Ω–∞–ª–æ–≥ n8n ICredentialType)
 * –ù–∞–ø—Ä–∏–º–µ—Ä: "gigachatApi"
 */
export interface ICredentialType {
  name: string;              // —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID —Ç–∏–ø–∞ ("gigachatApi")
  displayName: string;       // —á–∏—Ç–∞–µ–º–æ–µ –∏–º—è ("GigaChat API Credential")
  properties: ICredentialProperty[];
}

/**
 * –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–π credential (–∫–∞–∫ n8n StoredCredential)
 */
export interface IStoredCredential {
  id: string;                      // —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID —ç–∫–∑–µ–º–ø–ª—è—Ä–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä "1734986579102"
  name: string;                    // –∏–º—è, –∫–æ—Ç–æ—Ä–æ–µ –≤—ã–±–µ—Ä–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ("–ú–æ–π GigaChat —Ç–æ–∫–µ–Ω")
  type: string;                    // credentialType.name (–Ω–∞–ø—Ä–∏–º–µ—Ä: "gigachatApi")

  /** 
   * data —Å–æ–¥–µ—Ä–∂–∏—Ç –ø–∞—Ä—ã –∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä:
   * { clientId: "...", clientSecret: "..." }
   * 
   * !!! –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –∑–¥–µ—Å—å –¥–æ–ª–∂–Ω—ã —Ö—Ä–∞–Ω–∏—Ç—å—Å—è –≤ –ó–ê–®–ò–§–†–û–í–ê–ù–ù–û–ú –≤–∏–¥–µ !!!
   */
  data: Record<string, any>;

  createdAt: string;
  updatedAt?: string;
}


–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\types\helpers.ts:
// types/helpers.ts
import { IItem } from "./nodes";

/**
 * –¢–∏–ø –æ–ø—Ü–∏–π –¥–ª—è httpRequest ‚Äî –º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä—è—Ç—å (axios-like)
 */
export interface IHttpRequestOptions {
  method?: "GET" | "POST" | "PUT" | "DELETE" | string;
  url: string;
  headers?: Record<string, string>;
  params?: Record<string, any>;
  data?: any;
  timeout?: number;
  // internal: allow to bypass TLS only for dev and specific hosts
  _insecureSkipTLS?: boolean;
}

/**
 * –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –Ω–∞–±–æ—Ä –º–µ—Ç–æ–¥–æ–≤ helper'–∞ (—Ä–∞—Å—à–∏—Ä—è–µ–º—ã–π)
 */
export interface IHelpers {
  log: (...args: any[]) => void;
  httpRequest: (opts: IHttpRequestOptions) => Promise<any>;
  returnJsonArray: (items: IItem[] | any[]) => IItem[];
  getCredential?: (name: string) => Promise<Record<string, any> | undefined>;
  // runtime context getter
  getContext?: () => Record<string, any>;
  // extensible bag for future helpers
  [key: string]: any;
}


–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\types\nodes.ts:
// backend/types/nodes.ts

/**
 * –¢–∏–ø—ã –∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è –Ω–æ–¥ (INodeType / INodeTypeDescription)
 *
 * –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞: n8n-like Smart Context
 */

export type NodeTypeName = string;
export type PortName = string;

/**
 * –û–ø–∏—Å–∞–Ω–∏–µ credential (–ø–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ –∏–º—è)
 */
export interface INodeCredentialDescription {
  name: string; // credentialType (–Ω–∞–ø—Ä–∏–º–µ—Ä, "gigachatApi")
  required?: boolean;
}

/**
 * –û–¥–Ω–∞ "–µ–¥–∏–Ω–∏—Ü–∞ –¥–∞–Ω–Ω—ã—Ö" ‚Äî —ç–ª–µ–º–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π –≥—É–ª—è–µ—Ç –º–µ–∂–¥—É –Ω–æ–¥–∞–º–∏.
 */
export interface IItem {
  json: Record<string, any>;
  [key: string]: any;
}

/**
 * –û–ø–∏—Å–∞–Ω–∏–µ –æ–¥–Ω–æ–≥–æ —Å–≤–æ–π—Å—Ç–≤–∞ (–ø–æ–ª–µ –≤ UI) –Ω–æ–¥—ã.
 */
export interface INodeProperty {
  name: string;
  type: string;
  displayName?: string;
  default?: any;
  typeOptions?: Record<string, any>;
  options?: Array<{ name: string; value: string }>;
  placeholder?: string;
  description?: string;
  required?: boolean;
  // future: displayOptions
}

// ===========================================
// === 1. –ò–ù–¢–ï–†–§–ï–ô–° –§–£–ù–ö–¶–ò–ô –ö–û–ù–¢–ï–ö–°–¢–ê (THIS) ===
// ===========================================

/**
 * –ù–∞–±–æ—Ä —Ñ—É–Ω–∫—Ü–∏–π, –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —á–µ—Ä–µ–∑ 'this' –≤–Ω—É—Ç—Ä–∏ –º–µ—Ç–æ–¥–∞ execute() –Ω–æ–¥—ã.
 */
export interface IExecuteFunctions {
  // –ü–æ–ª—É—á–∏—Ç—å –≤—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
  getInputData(inputName?: string): IItem[];

  /**
   * –ü–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –Ω–æ–¥—ã. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã—á–∏—Å–ª—è–µ—Ç –≤—ã—Ä–∞–∂–µ–Ω–∏—è ({{ $json.field }}).
   * @param parameterName ‚Äî –ò–º—è —Å–≤–æ–π—Å—Ç–≤–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 'prompt' –∏–ª–∏ 'condition').
   * @param itemIndex ‚Äî –ò–Ω–¥–µ–∫—Å —Ç–µ–∫—É—â–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ (–¥–ª—è $json).
   * @param fallbackValue ‚Äî –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –µ—Å–ª–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä –Ω–µ –∑–∞–¥–∞–Ω.
   */
  getNodeParameter(
    parameterName: string,
    itemIndex: number,
    fallbackValue?: any
  ): any;

  // –î–æ—Å—Ç—É–ø –∫ —Ö–µ–ª–ø–µ—Ä–∞–º (–ª–æ–≥–≥–µ—Ä, –∞–ø–∏, getCredentials)
  helpers: any;

  // –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Ç–µ–∫—É—â–µ–π –Ω–æ–¥—ã
  getNode(): { id: string; name: string; type: string };
}

// =======================================
// === 2. –û–ü–ò–°–ê–ù–ò–ï –°–¢–†–£–ö–¢–£–†–´ –ù–û–î–´ (TYPE) ===
// =======================================

/**
 * –û–ø–∏—Å–∞–Ω–∏–µ –æ–¥–Ω–æ–≥–æ –ø–æ—Ä—Ç–∞ (–≤—Ö–æ–¥/–≤—ã—Ö–æ–¥).
 */
export interface INodePort {
  id: string; // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π ID (–Ω–∞–ø—Ä–∏–º–µ—Ä, "output_true")
  displayName: string; // –ù–∞–¥–ø–∏—Å—å –≤ UI (–Ω–∞–ø—Ä–∏–º–µ—Ä, "True")
}

/**
 * –û–ø–∏—Å–∞–Ω–∏–µ –Ω–æ–¥—ã ‚Äî –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ, –∫–æ—Ç–æ—Ä—ã–µ –¥–≤–∏–∂–æ–∫ –∏ UI –∏—Å–ø–æ–ª—å–∑—É—é—Ç.
 */
export interface INodeTypeDescription {
  name: string;
  displayName?: string;

  inputs?: INodePort[];
  outputs?: INodePort[];
  trigger?: boolean;
  properties?: INodeProperty[];
  credentials?: INodeCredentialDescription[];
}

/**
 * –ü–æ–ª–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–æ–¥—ã, –∑–∞–≥—Ä—É–∂–∞–µ–º–æ–µ –¥–≤–∏–∂–∫–æ–º.
 */
export interface INodeType {
  // 1. –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –ª–µ–∂–∞—Ç –≤–Ω—É—Ç—Ä–∏ description
  description: INodeTypeDescription;

  /**
   * 2. execute –Ω–µ –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∞—Ä–≥—É–º–µ–Ω—Ç—ã, –∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç this (IExecuteFunctions).
   * –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç Promise —Å –º–∞—Å—Å–∏–≤–æ–º IItem (–¥–ª—è –æ–¥–Ω–æ–≥–æ –≤—ã—Ö–æ–¥–∞) –∏–ª–∏ Map<PortName, IItem[]>
   */
  execute(
    this: IExecuteFunctions
  ): Promise<IItem[] | Record<PortName, IItem[]>>;
}

// Alias –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
export type INodeDefinition = INodeType;

–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\types\workflow.ts:
// types/workflow.ts
import { IItem } from "./nodes";

/**
 * –≠–∫–∑–µ–º–ø–ª—è—Ä –Ω–æ–¥—ã –≤ workflow.
 */

export interface IWorkflowNodeInstance {
  id: string;
  type: string;
  position?: { x: number; y: number };
  data?: Record<string, any>;

  /**
   * Credentials, –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–µ –∫ —ç—Ç–æ–π –Ω–æ–¥–µ
   */
  credentials?: {
    [credentialType: string]: {
      id: string;   // ID —Ö—Ä–∞–Ω–∏–º–æ–≥–æ –Ω–∞–±–æ—Ä–∞ –∫–ª—é—á–µ–π
    };
  };
}

/**
 * –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –º–µ–∂–¥—É –Ω–æ–¥–∞–º–∏ (edge).
 */
export interface IWorkflowConnection {
  /** –£–Ω–∏–∫–∞–ª—å–Ω—ã–π ID —Å–≤—è–∑–∏ (–Ω–µ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω) */
  id?: string;

  /** ID –Ω–æ–¥—ã-–∏—Å—Ç–æ—á–Ω–∏–∫–∞ */
  source: string;

  /** –í—ã—Ö–æ–¥–Ω–æ–π –ø–æ—Ä—Ç –∏—Å—Ç–æ—á–Ω–∏–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä "output_true") */
  sourceHandle?: string;

  /** ID –Ω–æ–¥—ã-–ø—Ä–∏—ë–º–Ω–∏–∫–∞ */
  target: string;

  /** –í—Ö–æ–¥–Ω–æ–π –ø–æ—Ä—Ç —Ü–µ–ª–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä "input") */
  targetHandle?: string;
}

/**
 * –ü–æ–ª–Ω–∞—è —Å—Ö–µ–º–∞ workflow –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è/–∑–∞–≥—Ä—É–∑–∫–∏.
 */
export interface IWorkflowSchema {
  id?: string;
  name?: string;

  /** –≠–∫–∑–µ–º–ø–ª—è—Ä—ã –Ω–æ–¥ */
  nodes: IWorkflowNodeInstance[];

  /** –°–æ–µ–¥–∏–Ω–µ–Ω–∏—è –º–µ–∂–¥—É –Ω–æ–¥–∞–º–∏ */
  edges: IWorkflowConnection[];

  /** –ü—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–µ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Å—Ö–µ–º—ã */
  meta?: Record<string, any>;
}

/**
 * –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –¥–≤–∏–∂–∫–∞.
 * Key: nodeId ‚Üí output port ‚Üí –º–∞—Å—Å–∏–≤ —ç–ª–µ–º–µ–Ω—Ç–æ–≤.
 */
export type IExecutionMap = Record<
  string,
  Record<string, IItem[]>
>;

/**
 * –ü—Ä–µ–≤—å—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –æ–¥–Ω–æ–π –Ω–æ–¥—ã –¥–ª—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
 * (–Ω–∞–ø—Ä–∏–º–µ—Ä –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è Output-–ø–∞–Ω–µ–ª–∏).
 */
export interface INodePreview {
  nodeId: string;
  data: {
    output: string;
  };
}

/**
 * –ü–æ–ª–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è workflow.
 * –¢–æ, —á—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ /run.
 */
export interface IExecutionPreview {
  results: INodePreview[];
  runId?: string;
  stats?: Record<string, any>;
}

export interface INodeExecutionData {
  json: any;
  meta?: {
    preview?: string;
    [key: string]: any;
  };
}

export interface INodeRunData {
  input: INodeExecutionData[];
  output: INodeExecutionData[];
  startTime: number;
  endTime: number;
  error?: string;
}

export interface IWorkflowListItem {
  id: string;
  name: string;
  savedAt: string;
  nodesCount: number;
  edgesCount: number;
}

–°–æ–¥–µ—Ä–∂–∏–º–æ–µ C:\Users\HAIER\Desktop\LLM\test\backend\utils\errorHandler.ts:
// backend/utils/errorHandler.ts
export function getErrorMessage(error: unknown): string {
  if (error instanceof Error) {
    return error.message;
  }
  if (typeof error === 'string') {
    return error;
  }
  if (error && typeof error === 'object' && 'message' in error) {
    return String((error as any).message);
  }
  return 'Unknown error';
}

–ê–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω. –†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ D:\structurizer\structurizer\storage\outputs\backend_20260103_013158.txt
